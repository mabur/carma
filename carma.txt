* Strict warnings
* Naming conflicts for macros that introduce local variables, that could be the same as a user variable.
  - Related to shadowing warnings. So good that the user can get warning when this happens.
  - Could circumvent by using less generic names for local variable inside macros.
* Simulate closures, by having extra parameters.
* Json
* Csv
* Compare arrays and slices in Golang:
  - "An array has a fixed size."
  - "A slice, on the other hand, is a dynamically-sized, flexible view into the elements of an array."
  - "In practice, slices are much more common than arrays."
* Memory handling
  - Some memory can be allocated once and freed when the program exits.
  - Some memory can be allocated once and then grow/append as needed during run-time, and then freed when the program exits.
  - Some memory can be allocated as static variable inside function, and shared for all calls to the functions, and freed when the program exits.
  - Some memory can be allocated for a game interval, like a frame or a scene, and then deallocated/cleared after that frame or scene.
  - Some memory can be allocated on the stack using alloca (C&C++) or VLA (C). At least arrays up to ~1000 primitives.
  - What common cases are left?
* Similar libraries:
  - github.com/stclib/STC
  - github.com/mickjc750/str
  - github.com/chrizbazley/strb_t
  - gustedt.gitlabpages.inria.fr/ellipsis/structellipsis__str8.html
* Logo. Elephant and/or Sanskrit letter Ca
* Associative table
  - Can circumvent custom hashing and equality functions
    by having macros that can take multiple keys,
    such that each key is a primitive type that we can safely call sizeof for.
  - How to handle non-primitive keys, for example c-strings?
    - Could have macros that take a range as key.
    - Could require that equal strings should have equal pointers,
      which could be achieved by a string pool. 
  - Consider AOS instead of SOA.
    - AOS merges nicely with general range concept.
    - AOS could re-use range macros.
    - AOS requires fewer custom struct definitions by user.
  - Tsoding hash table in C:
    - https://www.youtube.com/watch?v=n-S9DBwPGTo
  - CppCon 2017: Matt Kulukundis “Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step”
    - Google SwissTable
    - https://www.youtube.com/watch?v=ncHmEUmJZf4
    - Have occupancy byte that stores both: occupancy, deleted, part of the hash.
* Describe range concepts as:
  - Fixed Ranges, that cannot change size, for example image.
  - Dynamic Arrays, that can shrink or grow at the end.
  - Ranges that can shrink at the beginning.
  - Ranges that can shrink at the end.
  - What is the right representation? Tree, Graph, something more modular? A binary periodic table over all abstract stuctures and macros?
  - Describe as tree or graph or modular concepts. A child is a parent, but not the other way around.
    - Range (for loops)
      - Directional Range / (has front and back etc)
        - Front Shrinkable Range
        - Back Shrinkable Range
          - Dynamic Array
      - Image
    - Table
* Make it so that a table just looks like a Dynamic Array,
  but that it is only an implementation detail and that it is not a range.
  - Add table versions of: FOR_EACH_TABLE, FILL_TABLE, COUNT_TABLE, IS_EMPTY_TABLE,
    FOR_MIN_TABLE, FOR_MAX_TABLE, ARE_EQUAL_TABLE, ERASE_KEY, ERASE_VALUE, ERASE_IF_TABLE, CONCAT_TABLE
  - Would it be meanmingful to re-use to share the implementation for some of them?


From Falco Girgis:
// alloca()
#ifndef GBL_ALLOCA
//#   ifndef alloca
#       if defined(__APPLE__) || defined(__GLIBC__) || defined(__sun) || defined(__CYGWIN__) || defined(__EMSCRIPTEN__) || defined(VITA) || defined(__DREAMCAST__) || defined(PSP)
#           include <alloca.h>     // alloca
#       elif defined(_WIN32)
#           include <malloc.h>     // alloca
#           ifndef alloca
#               define alloca _alloca  // for clang with MS Codegen
#           endif
#       else
#           include <stdlib.h>     // alloca
#       endif
//#   endif
#   define GBL_ALLOCA alloca
#endif
